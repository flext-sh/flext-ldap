"""ðŸš€ LDAP Core Shared - Unified Enterprise LDAP Library.

**Modern Python LDAP library with enterprise features and unified API**

**Key Features:**
- âœ… **Python 3.9+ Support**: Compatible with Python 3.9 through 3.13
- âš¡ **Unified API**: Single, clean interface for all LDAP operations
- ðŸ›¡ï¸ **Enterprise Security**: SSL/TLS, SASL, and comprehensive authentication
- ðŸ”„ **Migration Tools**: Oracle OID â†’ OUD, Active Directory, OpenLDAP
- ðŸ“Š **Schema Management**: Automated discovery, comparison, and validation
- ðŸŽ¯ **Zero-Complexity APIs**: Simple interfaces for complex operations
- ðŸ” **LDIF Processing**: High-speed streaming for large datasets
- ðŸ“ˆ **Performance Monitoring**: Built-in metrics and health checking
- ðŸ§ª **Type Safety**: Full type hints and Pydantic validation

**Quick Start:**
    Basic LDAP operations with unified API:

    >>> import asyncio
    >>> from ldap_core_shared import LDAP, LDAPConfig
    >>>
    >>> # Simple connection and search
    >>> async def basic_example():
    ...     config = LDAPConfig(
    ...         server="ldaps://ldap.company.com:636",
    ...         auth_dn="cn=admin,dc=company,dc=com",
    ...         auth_password="secret",
    ...         base_dn="dc=company,dc=com"
    ...     )
    ...     async with LDAP(config) as ldap:
    ...         users = await ldap.find_users_in_department("IT")
    ...         if users.success:
    ...             print(f"Found {len(users.data)} users")
    >>>
    >>> asyncio.run(basic_example())

**Fluent Queries:**
    Chainable query building:

    >>> async with LDAP(config) as ldap:
    ...     result = await (ldap.query()
    ...         .users()
    ...         .in_department("Engineering")  
    ...         .with_title("*Manager*")
    ...         .enabled_only()
    ...         .select("cn", "mail", "title")
    ...         .limit(25)
    ...         .execute())

**Convenience Functions:**
    One-liner connections:

    >>> from ldap_core_shared import ldap_session
    >>>
    >>> async with ldap_session(
    ...     server="ldap://ldap.company.com",
    ...     auth_dn="cn=service,dc=company,dc=com",
    ...     auth_password="secret",
    ...     base_dn="dc=company,dc=com"
    ... ) as ldap:
    ...     user = await ldap.find_user_by_email("john@company.com")

**Compatibility:**
    - Python 3.9+ (tested on 3.9, 3.10, 3.11, 3.12, 3.13)
    - LDAP v2/v3 protocols (RFC 4511 compliant)
    - Oracle Internet Directory (OID), Oracle Unified Directory (OUD)
    - Active Directory, OpenLDAP, Apache DS, 389 Directory Server
    - Async/await and traditional synchronous patterns

Version: {__version__}
Author: {__author__}
License: {__license__}
"""

from __future__ import annotations

import logging
import sys
from typing import TYPE_CHECKING

# Optional imports for structured logging
try:
    import structlog
except ImportError:
    structlog = None  # type: ignore[assignment]

from ldap_core_shared.utils.constants import (
    DEFAULT_LARGE_LIMIT,
    DEFAULT_MAX_ITEMS,
    LDAP_DEFAULT_PORT,
)

# Import version information from centralized module
from ldap_core_shared.version import (
    AUTHOR as __author__,  # noqa: N811
)
from ldap_core_shared.version import (
    AUTHOR_EMAIL as __email__,  # noqa: N811
)
from ldap_core_shared.version import (
    LICENSE as __license__,  # noqa: N811
)
from ldap_core_shared.version import (
    __version__,
    get_package_info,
    get_version_tuple,
    is_compatible_python_version,
    is_stable_release,
)

__copyright__ = "2025 LDAP Core Team"

# Python 3.9+ compatibility enforcement
if not is_compatible_python_version((sys.version_info.major, sys.version_info.minor)):
    msg = (
        f"ldap-core-shared requires Python 3.9 or higher. "
        f"You are using Python {sys.version_info.major}.{sys.version_info.minor}. "
        f"Please upgrade your Python version to use this library."
    )
    raise RuntimeError(msg)

# Type checking imports - only available during static analysis

# ðŸš€ Public API - Unified and clean exports focused on the main API
__all__ = [
    # ðŸŽ¯ UNIFIED API - Primary interface (recommended)
    "LDAP",  # Main unified LDAP interface
    "LDAPConfig",  # Simple configuration class
    "Result",  # Universal result wrapper
    "Query",  # Fluent query builder
    "connect",  # Quick connection function
    "ldap_session",  # Context manager for sessions

    # ðŸ“„ CORE DATA MODELS - Essential models
    "LDAPEntry",  # LDAP entry representation
    "LDAPResult",  # Operation result wrapper (legacy)

    # ðŸ”„ CORE PROCESSING - Essential processors
    "LDIFProcessor",  # Main LDIF processor
    "LDIFEntry",  # LDIF entry representation

    # ðŸ” SCHEMA MANAGEMENT - Core schema operations
    "SchemaDiscovery",  # Schema discovery and analysis
    "SchemaValidator",  # Schema validation

    # âš ï¸ CORE EXCEPTIONS - Essential error handling
    "LDAPCoreError",  # Base LDAP exception
    "ValidationError",  # Data validation errors
    "ConnectionError",  # Connection-related errors
    "AuthenticationError",  # Authentication failures

    # ðŸ› ï¸ UTILITIES - Core utilities
    "get_logger",  # Logger factory

    # ðŸ“Š METADATA - Package information
    "__version__",
    "__author__",
    "__email__",
    "__license__",
    "__copyright__",
    "get_package_info",
    "get_version_tuple",
    "is_stable_release",
]

# ðŸš€ Lazy import mappings for optimal performance and Python 3.9+ compatibility
_LAZY_IMPORTS = {
    # ðŸŽ¯ UNIFIED API - Primary interface
    "LDAP": ("ldap_core_shared.api", "LDAP"),
    "LDAPConfig": ("ldap_core_shared.api", "LDAPConfig"),
    "Result": ("ldap_core_shared.api", "Result"),
    "Query": ("ldap_core_shared.api", "Query"),
    "connect": ("ldap_core_shared.api", "connect"),
    "ldap_session": ("ldap_core_shared.api", "ldap_session"),

    # ðŸ“„ CORE DATA MODELS
    "LDAPEntry": ("ldap_core_shared.domain.models", "LDAPEntry"),
    "LDAPResult": ("ldap_core_shared.domain.results", "LDAPResult"),

    # ðŸ”„ CORE PROCESSING
    "LDIFProcessor": ("ldap_core_shared.core.ldif_processor", "LDIFProcessor"),
    "LDIFEntry": ("ldap_core_shared.ldif.parser", "LDIFEntry"),

    # ðŸ” SCHEMA MANAGEMENT
    "SchemaDiscovery": ("ldap_core_shared.schema.discovery", "SchemaDiscovery"),
    "SchemaValidator": ("ldap_core_shared.schema.validator", "SchemaValidator"),

    # âš ï¸ CORE EXCEPTIONS
    "LDAPCoreError": ("ldap_core_shared.core.exceptions", "LDAPCoreError"),
    "ValidationError": ("ldap_core_shared.core.exceptions", "ValidationError"),
    "ConnectionError": ("ldap_core_shared.core.exceptions", "ConnectionError"),
    "AuthenticationError": ("ldap_core_shared.core.exceptions", "AuthenticationError"),

    # ðŸ› ï¸ UTILITIES
    "get_logger": ("ldap_core_shared.utils.logging", "get_logger"),
}


def __getattr__(name: str) -> object:
    """Lazy import of public API components for optimal performance.

    Args:
        name: The name of the attribute being accessed

    Returns:
        The requested module component

    Raises:
        AttributeError: If the requested attribute doesn't exist
    """
    if name in _LAZY_IMPORTS:
        module_path, attr_name = _LAZY_IMPORTS[name]
        module = __import__(module_path, fromlist=[attr_name])
        return getattr(module, attr_name)

    # Unknown attribute
    msg = f"module '{__name__}' has no attribute '{name}'"
    raise AttributeError(msg)


# Module initialization - minimal setup for fast imports
def _initialize_module() -> None:
    """Initialize module with minimal overhead for fast startup."""
    # Configure structured logging if not already configured
    if structlog is not None and not structlog.is_configured():
        structlog.configure(
            processors=[
                structlog.stdlib.filter_by_level,
                structlog.stdlib.add_logger_name,
                structlog.stdlib.add_log_level,
                structlog.stdlib.PositionalArgumentsFormatter(),
                structlog.processors.TimeStamper(fmt="iso"),
                structlog.processors.StackInfoRenderer(),
                structlog.processors.format_exc_info,
                structlog.processors.UnicodeDecoder(),
                structlog.processors.JSONRenderer(),
            ],
            wrapper_class=structlog.stdlib.BoundLogger,
            logger_factory=structlog.stdlib.LoggerFactory(),
            cache_logger_on_first_use=True,
        )
    else:
        # structlog not available, skip configuration
        # Using standard library logging as fallback
        logging.basicConfig(level=logging.INFO)


# Initialize module on import
_initialize_module()
