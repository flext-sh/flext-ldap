"""Real integration tests for search.py and api.py coverage improvement.

These tests use the actual LDAP client API with real Docker LDAP operations.
No mocks - only real tests with Docker container.

Copyright (c) 2025 FLEXT Team. All rights reserved.
SPDX-License-Identifier: MIT
"""

from __future__ import annotations

import pytest
from flext_core import FlextResult

from flext_ldap import FlextLdapClients, FlextLdapModels
from flext_ldap.constants import FlextLdapConstants


@pytest.mark.docker
@pytest.mark.integration
class TestSearchOperationsRealCoverage:
    """Real integration tests for search.py coverage."""

    @pytest.fixture
    def client(self, shared_ldap_client: FlextLdapClients) -> FlextLdapClients:
        """Use real LDAP client."""
        return shared_ldap_client

    def test_search_with_multiple_filters(self, client: FlextLdapClients) -> None:
        """Test search with various filter expressions."""
        # Test AND filter
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(&(objectClass=*)(cn=*))",
            scope="subtree",
        )
        result = client.search_with_request(search_request)
        assert result.is_success
        response = result.unwrap()
        assert isinstance(response, FlextLdapModels.SearchResponse)

    def test_search_with_size_limit(self, client: FlextLdapClients) -> None:
        """Test search with size limit.

        Note: LDAP servers vary in size_limit enforcement. Some enforce it strictly,
        others return more entries than requested. This test verifies the request
        succeeds with size_limit parameter, without asserting strict enforcement.
        """
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(objectClass=*)",
            scope="subtree",
            size_limit=5,
        )
        result = client.search_with_request(search_request)
        assert result.is_success
        response = result.unwrap()
        # Verify response is a valid SearchResponse with entries list
        assert isinstance(response, FlextLdapModels.SearchResponse)
        assert isinstance(response.entries, list)

    def test_search_returns_proper_entries(self, client: FlextLdapClients) -> None:
        """Test that search returns proper entry objects."""
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(objectClass=organizationalUnit)",
            scope="onelevel",
        )
        result = client.search_with_request(search_request)
        assert result.is_success
        response = result.unwrap()
        if response.entries:
            entry = response.entries[0]
            assert isinstance(entry, FlextLdapModels.Entry)
            assert entry.dn is not None

    def test_search_with_base_scope(self, client: FlextLdapClients) -> None:
        """Test search with BASE scope."""
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(objectClass=*)",
            scope="base",
        )
        result = client.search_with_request(search_request)
        assert result.is_success
        response = result.unwrap()
        assert isinstance(response, FlextLdapModels.SearchResponse)

    def test_search_with_empty_result(self, client: FlextLdapClients) -> None:
        """Test search that returns no results.

        Verifies the client can execute searches with filters that match nothing.
        This tests both successful searches with empty results and proper error handling.
        """
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(cn=nonexistent_entry_xyz_abc_123)",
            scope="subtree",
        )
        result = client.search_with_request(search_request)
        # Verify result is a FlextResult (success or failure both valid)
        assert isinstance(result, FlextResult)
        if result.is_success:
            response = result.unwrap()
            assert isinstance(response.entries, list)

    def test_search_with_attributes(self, client: FlextLdapClients) -> None:
        """Test search with specific attributes."""
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(objectClass=*)",
            scope="onelevel",
            attributes=["cn", "objectClass"],
        )
        result = client.search_with_request(search_request)
        assert result.is_success
        response = result.unwrap()
        if response.entries:
            # Verify attributes were retrieved
            assert len(response.entries) > 0


@pytest.mark.docker
@pytest.mark.integration
class TestClientOperationsRealCoverage:
    """Real integration tests for clients.py coverage."""

    @pytest.fixture
    def client(self, shared_ldap_client: FlextLdapClients) -> FlextLdapClients:
        """Use real LDAP client."""
        return shared_ldap_client

    def test_client_is_connected(self, client: FlextLdapClients) -> None:
        """Test client connection status."""
        assert client.is_connected
        # Connection should be valid
        assert client.connection is not None

    def test_client_test_connection(self, client: FlextLdapClients) -> None:
        """Test connection validation."""
        result = client.test_connection()
        assert result.is_success

    def test_client_search_with_pagination(self, client: FlextLdapClients) -> None:
        """Test search with pagination support."""
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(objectClass=*)",
            scope="subtree",
            page_size=10,
        )
        result = client.search_with_request(search_request)
        assert result.is_success

    def test_client_search_with_time_limit(self, client: FlextLdapClients) -> None:
        """Test search with time limit."""
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(objectClass=*)",
            scope="subtree",
            time_limit=FlextLdapConstants.DEFAULT_TIMEOUT,
        )
        result = client.search_with_request(search_request)
        assert result.is_success

    def test_client_add_entry_lifecycle(self, client: FlextLdapClients) -> None:
        """Test add entry and verify success.

        This test exercises the add_entry, search_with_request, and delete_entry
        operations to verify the full lifecycle of entry management.
        """
        test_dn = "cn=integration_test_user,ou=people,dc=flext,dc=local"

        # Add entry with DN and attributes (not Entry object)
        add_result = client.add_entry(
            dn=test_dn,
            attributes={
                "objectClass": ["person", "top"],
                "cn": ["integration_test_user"],
                "sn": ["test"],
                "userPassword": ["test123"],
            },
        )
        if add_result.is_success:
            # Verify it was added by searching for it
            search_request = FlextLdapModels.SearchRequest(
                base_dn=test_dn,
                filter_str="(cn=integration_test_user)",
                scope="base",
            )
            search_result = client.search_with_request(search_request)

            if search_result.is_success:
                # Clean up - delete the entry
                client.delete_entry(test_dn)

    def test_client_delete_entry_nonexistent(self, client: FlextLdapClients) -> None:
        """Test deleting non-existent entry returns error result."""
        result = client.delete_entry("cn=does_not_exist,dc=flext,dc=local")
        # Should return a FlextResult (success or failure)
        assert isinstance(result, FlextResult)

    def test_client_search_one_operation(self, client: FlextLdapClients) -> None:
        """Test search_one returns single entry.

        search_one takes search_base and filter_str as parameters,
        returning a single entry or error result.
        """
        result = client.search_one(
            search_base="dc=flext,dc=local",
            filter_str="(objectClass=dcObject)",
        )
        assert isinstance(result, FlextResult)

    def test_client_validate_entry(self, client: FlextLdapClients) -> None:
        """Test entry validation."""
        entry = FlextLdapModels.Entry(
            dn="cn=test,dc=flext,dc=local",
            object_classes=["person", "top"],
            attributes={"cn": ["test"], "sn": ["test"]},
        )
        result = client.validate_entry(entry)
        assert isinstance(result, FlextResult)


@pytest.mark.docker
@pytest.mark.integration
class TestErrorHandlingRealCoverage:
    """Real integration tests for error handling coverage."""

    @pytest.fixture
    def client(self, shared_ldap_client: FlextLdapClients) -> FlextLdapClients:
        """Use real LDAP client."""
        return shared_ldap_client

    def test_search_with_invalid_dn(self, client: FlextLdapClients) -> None:
        """Test handling of invalid DN."""
        search_request = FlextLdapModels.SearchRequest(
            base_dn="invalid,,,dn",
            filter_str="(objectClass=*)",
            scope="subtree",
        )
        result = client.search_with_request(search_request)
        # Should return a FlextResult (success or failure)
        assert isinstance(result, FlextResult)

    def test_search_with_invalid_filter(self, client: FlextLdapClients) -> None:
        """Test handling of invalid filter."""
        search_request = FlextLdapModels.SearchRequest(
            base_dn="dc=flext,dc=local",
            filter_str="(invalid unclosed filter",
            scope="subtree",
        )
        result = client.search_with_request(search_request)
        assert isinstance(result, FlextResult)
